Index: libpng/Makefile.am
===================================================================
--- libpng.orig/Makefile.am	2012-12-29 21:37:00.000000000 +0200
+++ libpng/Makefile.am	2012-12-29 21:38:22.000000000 +0200
@@ -34,7 +34,8 @@
 libpng12_la_SOURCES = png.c pngset.c pngget.c pngrutil.c pngtrans.c pngwutil.c \
 	pngread.c pngrio.c pngwio.c pngwrite.c pngrtran.c \
 	pngwtran.c pngmem.c pngerror.c pngpread.c \
-	png.h pngconf.h
+	png.h pngconf.h \
+	png_read_filter_row_neon.S
 libpng_la_SOURCES = $(libpng12_la_SOURCES)
 
 libpng_la_CPPFLAGS = @LIBPNG_DEFINES@
Index: libpng/configure.ac
===================================================================
--- libpng.orig/configure.ac	2012-12-29 21:37:00.000000000 +0200
+++ libpng/configure.ac	2012-12-29 21:38:22.000000000 +0200
@@ -33,6 +33,8 @@
 AC_CONFIG_SRCDIR([pngget.c])
 AM_CONFIG_HEADER(config.h)
 
+AM_PROG_AS
+
 # Checks for programs.
 AC_PROG_CC
 AC_PROG_LD
Index: libpng/png_read_filter_row_neon.S
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libpng/png_read_filter_row_neon.S	2012-12-29 18:33:52.000000000 +0200
@@ -0,0 +1,219 @@
+/* filter_neon.S - NEON optimised filter functions
+ *
+ * Copyright (c) 2011 Mans Rullgard
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#ifdef __ELF__
+#   define ELF
+#else
+#   define ELF @
+#endif
+
+        .arch armv7-a
+        .fpu  neon
+
+.macro  func    name, export=0
+    .macro endfunc
+ELF     .size   \name, . - \name
+        .endfunc
+        .purgem endfunc
+    .endm
+        .text
+    .if \export
+        .global \name
+    .endif
+ELF     .type   \name, STT_FUNC
+        .func   \name
+\name:
+.endm
+
+func    png_read_filter_row_sub4_neon, export=1
+        ldr             r3,  [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+1:
+        vld4.32         {d4[],d5[],d6[],d7[]},    [r1,:128]
+        vadd.u8         d0,  d3,  d4
+        vadd.u8         d1,  d0,  d5
+        vadd.u8         d2,  d1,  d6
+        vadd.u8         d3,  d2,  d7
+        vst4.32         {d0[0],d1[0],d2[0],d3[0]},[r1,:128]!
+        subs            r3,  r3,  #16
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_sub3_neon, export=1
+        ldr             r3,  [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+        mov             r0,  r1
+        mov             r2,  #3
+        mov             r12, #12
+        vld1.8          {q11},    [r0], r12
+1:
+        vext.8          d5,  d22, d23, #3
+        vadd.u8         d0,  d3,  d22
+        vext.8          d6,  d22, d23, #6
+        vadd.u8         d1,  d0,  d5
+        vext.8          d7,  d23, d23, #1
+        vld1.8          {q11},    [r0], r12
+        vst1.32         {d0[0]},  [r1,:32], r2
+        vadd.u8         d2,  d1,  d6
+        vst1.32         {d1[0]},  [r1], r2
+        vadd.u8         d3,  d2,  d7
+        vst1.32         {d2[0]},  [r1], r2
+        vst1.32         {d3[0]},  [r1], r2
+        subs            r3,  r3,  #12
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_up_neon, export=1
+        ldr             r3,  [r0, #4]           @ rowbytes
+1:
+        vld1.8          {q0}, [r1,:128]
+        vld1.8          {q1}, [r2,:128]!
+        vadd.u8         q0,  q0,  q1
+        vst1.8          {q0}, [r1,:128]!
+        subs            r3,  r3,  #16
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_avg4_neon, export=1
+        ldr             r12, [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+1:
+        vld4.32         {d4[],d5[],d6[],d7[]},    [r1,:128]
+        vld4.32         {d16[],d17[],d18[],d19[]},[r2,:128]!
+        vhadd.u8        d0,  d3,  d16
+        vadd.u8         d0,  d0,  d4
+        vhadd.u8        d1,  d0,  d17
+        vadd.u8         d1,  d1,  d5
+        vhadd.u8        d2,  d1,  d18
+        vadd.u8         d2,  d2,  d6
+        vhadd.u8        d3,  d2,  d19
+        vadd.u8         d3,  d3,  d7
+        vst4.32         {d0[0],d1[0],d2[0],d3[0]},[r1,:128]!
+        subs            r12, r12, #16
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_avg3_neon, export=1
+        push            {r4,lr}
+        ldr             r12, [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+        mov             r0,  r1
+        mov             r4,  #3
+        mov             lr,  #12
+        vld1.8          {q11},    [r0], lr
+1:
+        vld1.8          {q10},    [r2], lr
+        vext.8          d5,  d22, d23, #3
+        vhadd.u8        d0,  d3,  d20
+        vext.8          d17, d20, d21, #3
+        vadd.u8         d0,  d0,  d22
+        vext.8          d6,  d22, d23, #6
+        vhadd.u8        d1,  d0,  d17
+        vext.8          d18, d20, d21, #6
+        vadd.u8         d1,  d1,  d5
+        vext.8          d7,  d23, d23, #1
+        vld1.8          {q11},    [r0], lr
+        vst1.32         {d0[0]},  [r1,:32], r4
+        vhadd.u8        d2,  d1,  d18
+        vst1.32         {d1[0]},  [r1], r4
+        vext.8          d19, d21, d21, #1
+        vadd.u8         d2,  d2,  d6
+        vhadd.u8        d3,  d2,  d19
+        vst1.32         {d2[0]},  [r1], r4
+        vadd.u8         d3,  d3,  d7
+        vst1.32         {d3[0]},  [r1], r4
+        subs            r12, r12, #12
+        bgt             1b
+
+        pop             {r4,pc}
+endfunc
+
+.macro  paeth           rx,  ra,  rb,  rc
+        vaddl.u8        q12, \ra, \rb           @ a + b
+        vaddl.u8        q15, \rc, \rc           @ 2*c
+        vabdl.u8        q13, \rb, \rc           @ pa
+        vabdl.u8        q14, \ra, \rc           @ pb
+        vabd.u16        q15, q12, q15           @ pc
+        vcle.u16        q12, q13, q14           @ pa <= pb
+        vcle.u16        q13, q13, q15           @ pa <= pc
+        vcle.u16        q14, q14, q15           @ pb <= pc
+        vand            q12, q12, q13           @ pa <= pb && pa <= pc
+        vmovn.u16       d28, q14
+        vmovn.u16       \rx, q12
+        vbsl            d28, \rb, \rc
+        vbsl            \rx, \ra, d28
+.endm
+
+func    png_read_filter_row_paeth4_neon, export=1
+        ldr             r12, [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+        vmov.i8         d20, #0
+1:
+        vld4.32         {d4[],d5[],d6[],d7[]},    [r1,:128]
+        vld4.32         {d16[],d17[],d18[],d19[]},[r2,:128]!
+        paeth           d0,  d3,  d16, d20
+        vadd.u8         d0,  d0,  d4
+        paeth           d1,  d0,  d17, d16
+        vadd.u8         d1,  d1,  d5
+        paeth           d2,  d1,  d18, d17
+        vadd.u8         d2,  d2,  d6
+        paeth           d3,  d2,  d19, d18
+        vmov            d20, d19
+        vadd.u8         d3,  d3,  d7
+        vst4.32         {d0[0],d1[0],d2[0],d3[0]},[r1,:128]!
+        subs            r12, r12, #16
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_paeth3_neon, export=1
+        push            {r4,lr}
+        ldr             r12, [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+        vmov.i8         d4,  #0
+        mov             r0,  r1
+        mov             r4,  #3
+        mov             lr,  #12
+        vld1.8          {q11},    [r0], lr
+1:
+        vld1.8          {q10},    [r2], lr
+        paeth           d0,  d3,  d20, d4
+        vext.8          d5,  d22, d23, #3
+        vadd.u8         d0,  d0,  d22
+        vext.8          d17, d20, d21, #3
+        paeth           d1,  d0,  d17, d20
+        vst1.32         {d0[0]},  [r1,:32], r4
+        vext.8          d6,  d22, d23, #6
+        vadd.u8         d1,  d1,  d5
+        vext.8          d18, d20, d21, #6
+        paeth           d2,  d1,  d18, d17
+        vext.8          d7,  d23, d23, #1
+        vld1.8          {q11},    [r0], lr
+        vst1.32         {d1[0]},  [r1], r4
+        vadd.u8         d2,  d2,  d6
+        vext.8          d19, d21, d21, #1
+        paeth           d3,  d2,  d19, d18
+        vst1.32         {d2[0]},  [r1], r4
+        vmov            d4,  d19
+        vadd.u8         d3,  d3,  d7
+        vst1.32         {d3[0]},  [r1], r4
+        subs            r12, r12, #12
+        bgt             1b
+
+        pop             {r4,pc}
+endfunc
Index: libpng/pngrutil.c
===================================================================
--- libpng.orig/pngrutil.c	2012-12-29 21:37:00.000000000 +0200
+++ libpng/pngrutil.c	2012-12-29 22:06:05.000000000 +0200
@@ -23,6 +23,32 @@
 #  define WIN32_WCE_OLD
 #endif
 
+#if defined(__ARM_NEON__)
+extern void png_read_filter_row_neon(png_uint_32 rowbytes, png_byte pixel_depth, png_bytep row, png_bytep prev_row, int filter);
+PNG_EXTERN void png_read_filter_row_up_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_sub3_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_sub4_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_avg3_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_avg4_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_paeth3_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_bytep prev_row));
+PNG_EXTERN void png_read_filter_row_paeth4_neon PNGARG((png_row_infop row_info,
+    png_bytep row, png_bytep prev_row));
+
+static png_bytep align16(png_bytep row_buf)
+{
+   png_bytep temp = row_buf + 16;
+   int extra = (int)((temp - (png_bytep)0) & 0xf);
+   return temp - extra - 1/*filter byte*/;
+}
+
+#endif
+
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 #  ifdef WIN32_WCE_OLD
 /* The strtod() function is not supported on WindowsCE */
@@ -2926,120 +2952,191 @@
 }
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 
+static void
+png_read_filter_row_sub(png_row_infop row_info, png_bytep row,
+                        png_bytep prev_row)
+{
+  png_uint_32 i;
+  png_uint_32 istop = row_info->rowbytes;
+  png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
+  png_bytep rp = row + bpp;
+  png_bytep lp = row;
+
+  (void)(prev_row);
+
+  for (i = bpp; i < istop; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
+     rp++;
+  }
+}
+static void
+png_read_filter_row_up(png_row_infop row_info, png_bytep row,
+                        png_bytep prev_row)
+{
+   png_uint_32 i;
+   png_uint_32 istop = row_info->rowbytes;
+   png_bytep rp = row;
+   png_bytep pp = prev_row;
+
+   for (i = 0; i < istop; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+      rp++;
+   }
+}
+
+static void
+png_read_filter_row_avg(png_row_infop row_info, png_bytep row,
+                        png_bytep prev_row)
+{
+   png_uint_32 i;
+   png_bytep rp = row;
+   png_bytep pp = prev_row;
+   png_bytep lp = row;
+   png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
+   png_uint_32 istop = row_info->rowbytes - bpp;
+
+   for (i = 0; i < bpp; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         ((int)(*pp++) / 2 )) & 0xff);
+      rp++;
+   }
+
+   for (i = 0; i < istop; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         (int)(*pp++ + *lp++) / 2 ) & 0xff);
+      rp++;
+   }
+}
+
+static void
+png_read_filter_row_paeth(png_row_infop row_info, png_bytep row,
+                        png_bytep prev_row)
+{
+   png_uint_32 i;
+   png_bytep rp = row;
+   png_bytep pp = prev_row;
+   png_bytep lp = row;
+   png_bytep cp = prev_row;
+   png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
+   png_uint_32 istop=row_info->rowbytes - bpp;
+
+   for (i = 0; i < bpp; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+      rp++;
+   }
+
+   for (i = 0; i < istop; i++)   /* Use leftover rp,pp */
+   {
+      int a, b, c, pa, pb, pc, p;
+
+      a = *lp++;
+      b = *pp++;
+      c = *cp++;
+
+      p = b - c;
+      pc = a - c;
+
+#ifdef PNG_USE_ABS
+      pa = abs(p);
+      pb = abs(pc);
+      pc = abs(p + pc);
+#else
+      pa = p < 0 ? -p : p;
+      pb = pc < 0 ? -pc : pc;
+      pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
+
+      /*
+         if (pa <= pb && pa <= pc)
+            p = a;
+         else if (pb <= pc)
+            p = b;
+         else
+            p = c;
+       */
+
+      p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;
+
+      *rp = (png_byte)(((int)(*rp) + p) & 0xff);
+      rp++;
+   }
+}
 void /* PRIVATE */
 png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
    png_bytep prev_row, int filter)
 {
+   unsigned int bpp = (png_ptr->pixel_depth + 7) >> 3;
+
    png_debug(1, "in png_read_filter_row");
    png_debug2(2, "row = %lu, filter = %d", png_ptr->row_number, filter);
+
    switch (filter)
    {
       case PNG_FILTER_VALUE_NONE:
          break;
       case PNG_FILTER_VALUE_SUB:
       {
-         png_uint_32 i;
-         png_uint_32 istop = row_info->rowbytes;
-         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
-         png_bytep rp = row + bpp;
-         png_bytep lp = row;
+#if defined(__ARM_NEON__)
 
-         for (i = bpp; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
-            rp++;
-         }
+         if (bpp == 3)
+            png_read_filter_row_sub3_neon(row_info, row, prev_row);
+         else if (bpp == 4)
+               png_read_filter_row_sub4_neon(row_info, row, prev_row);
+         else
+            png_read_filter_row_sub(row_info, row, prev_row);
+
+#else
+         png_read_filter_row_sub(row_info, row, prev_row);
+#endif
          break;
       }
       case PNG_FILTER_VALUE_UP:
       {
-         png_uint_32 i;
-         png_uint_32 istop = row_info->rowbytes;
-         png_bytep rp = row;
-         png_bytep pp = prev_row;
+#if defined(__ARM_NEON__)
+         png_read_filter_row_up_neon(row_info, row, prev_row);
 
-         for (i = 0; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
-            rp++;
-         }
+#else
+         png_read_filter_row_up(row_info, row, prev_row);
+#endif
          break;
       }
       case PNG_FILTER_VALUE_AVG:
       {
-         png_uint_32 i;
-         png_bytep rp = row;
-         png_bytep pp = prev_row;
-         png_bytep lp = row;
-         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
-         png_uint_32 istop = row_info->rowbytes - bpp;
+#if defined(__ARM_NEON__)
+         unsigned int bpp = (png_ptr->pixel_depth + 7) >> 3;
 
-         for (i = 0; i < bpp; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) +
-               ((int)(*pp++) / 2 )) & 0xff);
-            rp++;
-         }
+         if (bpp == 3)
+            png_read_filter_row_avg3_neon(row_info, row, prev_row);
+         else if (bpp == 4)
+            png_read_filter_row_avg4_neon(row_info, row, prev_row);
+         else
+            png_read_filter_row_avg(row_info, row, prev_row);
 
-         for (i = 0; i < istop; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) +
-               (int)(*pp++ + *lp++) / 2 ) & 0xff);
-            rp++;
-         }
+#else
+         png_read_filter_row_avg(row_info, row, prev_row);
+#endif
          break;
       }
       case PNG_FILTER_VALUE_PAETH:
       {
-         png_uint_32 i;
-         png_bytep rp = row;
-         png_bytep pp = prev_row;
-         png_bytep lp = row;
-         png_bytep cp = prev_row;
-         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
-         png_uint_32 istop=row_info->rowbytes - bpp;
-
-         for (i = 0; i < bpp; i++)
-         {
-            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
-            rp++;
-         }
-
-         for (i = 0; i < istop; i++)   /* Use leftover rp,pp */
-         {
-            int a, b, c, pa, pb, pc, p;
-
-            a = *lp++;
-            b = *pp++;
-            c = *cp++;
+#if defined(__ARM_NEON__)
+         unsigned int bpp = (png_ptr->pixel_depth + 7) >> 3;
 
-            p = b - c;
-            pc = a - c;
+         if (bpp == 3)
+            png_read_filter_row_paeth3_neon(row_info, row, prev_row);
+         else if (bpp == 4)
+            png_read_filter_row_paeth4_neon(row_info, row, prev_row);
+         else
+            png_read_filter_row_paeth(row_info, row, prev_row);
 
-#ifdef PNG_USE_ABS
-            pa = abs(p);
-            pb = abs(pc);
-            pc = abs(p + pc);
 #else
-            pa = p < 0 ? -p : p;
-            pb = pc < 0 ? -pc : pc;
-            pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+         png_read_filter_row_paeth(row_info, row, prev_row);
 #endif
-
-            /*
-               if (pa <= pb && pa <= pc)
-                  p = a;
-               else if (pb <= pc)
-                  p = b;
-               else
-                  p = c;
-             */
-
-            p = (pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c;
-
-            *rp = (png_byte)(((int)(*rp) + p) & 0xff);
-            rp++;
-         }
          break;
       }
       default:
@@ -3339,6 +3436,7 @@
       png_error(png_ptr, "This image requires a row greater than 64KB");
 #endif
 
+   row_bytes+=64;
    if (row_bytes + 64 > png_ptr->old_big_row_buf_size)
    {
      png_free(png_ptr, png_ptr->big_row_buf);
@@ -3370,6 +3468,19 @@
       png_memset_check(png_ptr, png_ptr->prev_row, 0, row_bytes + 1);
       png_ptr->old_prev_row_size = row_bytes + 1;
    }
+#ifdef __ARM_NEON__
+   /* Use 16-byte aligned memory for row_buf with at least 16 bytes
+    * of padding before and after row_buf; treat prev_row similarly.
+    * NOTE: the alignment is to the start of the pixels, one beyond the start
+    * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this
+    * was incorrect; the filter byte was aligned, which had the exact
+    * opposite effect of that intended.
+    */
+   {
+      png_ptr->row_buf = align16(png_ptr->big_row_buf + 16);
+   }
+
+#endif
 
    png_ptr->rowbytes = row_bytes;
 
